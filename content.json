[{"title":"论如何对Java代码进行基本优化","date":"2017-03-05T07:03:38.000Z","path":"2017/03/05/论如何对Java代码进行基本优化/","text":"0、不要过度依赖GC内存抖动是指在短时间内有大量的对象被创建或者被回收的现象。内存抖动常出现的原因是频繁的在循环中创建对象，如果这种抖动很是频繁，会导致垃圾回收机制的频繁运行。 内存泄漏是指某段内存在程序功能上已经不再需要了，但是垃圾回收机制在回收内存时检测那段内存还是被需要的，不能被回收，这种在程序中没有被使用但是又不能被回收的内存就是泄漏的内存。内存泄漏会导致一些内存没法被正常利用，可用内存减少，轻则增加垃圾回收机制运行频率，重则内存溢出（当系统需要分配一段内存，但现有内存在垃圾回收运行之后仍然不足，就会内溢出） 常见的优化方式是在变量或对象使用完之后，将其手动置空。 1、优化循环语句 避免重复运算 //错误写法 for(int i = 0; i &lt;= vector.size(); i++){ ... } //正确写法 int size = vector.size(); for(int i = 0; i &lt;= size; i++){ ... } 错误写法中vector对象的size方法每次循环判断中都会调用，虽然该方法执行起来很快，但是叠加起来的性能损耗还是很可怕的。 在循环逻辑中避免大开销的操作所谓大开销的操作是指创建对象、捕获异常等需要大块内存消耗的操作。解决方案是在进行逻辑计算时应该尽量使用基本数据类型，比如int数组,string数组等，变量或对象使用后注意资源回收。 2、慎用异常机制执行异常捕获语句（try catch）和抛出异常（throw）的代价很高。使用异常机制尽量把逻辑放在最外层，并且只用于错误处理，不要用于程序逻辑。 3、基本数据类型运算java中的基本数据类型有byte、short、int、long、float、double、boolean、char，运算方式有加减乘除、位移、布尔运算。进行逻辑运算时需要注意： 运算速度从快到慢依次是int&gt;short&gt;byte&gt;long&gt;double 除法比乘法要慢很多，基本上除法的运算时间是乘法的9倍 long类型的运算很慢，建议少用 double运算速度和float相当 4、字符串操作使用StringBuffer提升效率//低效写法 String appendStr = &quot;test&quot;; int time = 10000; str = &quot;&quot;; for(i = 0; i &lt;= time; i++){ str += appendStr; } //高效写法 String appendStr = &quot;test&quot;; int time = 10000; StringBuffer sb = new StringBuffer(); for(i = 0; i &lt;= time; i++){ sb.append(appendStr); } 5、合理使用数据集合java的数据集合可分为两种类型，即集合结构（Collection）和图表结构（Map），下面还包括了列表（List），栈（Stack），散列（HashMap）等 Collection|- List| |- LinkedList (双向链表)| |- ArrayList (高级数组)| | Vector (线程安全)| | Stack|_ Set Map|- Hashtable (线程安全)|- HashMap|_ WeakHashMap 其中最常使用的是ArrayList ，该数据集合其实就是一个可变大小的数组，其次是LinkedList ，该集合用于实现栈（stack），队列（queue），双向队列（deque）。Hashtable是同步的 线程安全 。这些应该尽量使用ArrayList和HashMap，谨慎使用Vector和HashTable ，应为后两者为了保证线程安全而使用同步机制，系统开销比较大 编码时尽量使用原生的数据结构如数组，枚举 6、慎用public static final 如果一个变量或者数据被这样声明，那么我们就不能对这个变量进行任何修改了，这种数组也无法进行增删改查 以及排序等操作 这种声明的数据在整个进程被销毁之前都会常驻内存，使用不当有可能会引起一些性能问题。 7、使用对象池提高效率创建和释放对象会占用比较大的系统资源 即把常用的对象存放在一个对象池（对象集合）中，通过一定的策略高效调用已经存在的对象，避免大量的创建对象或销毁对象对象池 如数据库连接池 线程池 8、不要过度使用OOP善于使用语言中的工具类使用Log打印日志的系统资源开销也是不小的，在正式发布应用之前应该把程序中的Log调试代码关闭","tags":[{"name":"代码优化","slug":"代码优化","permalink":"http://yoursite.com/tags/代码优化/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/编程技巧/"}]},{"title":"java设计模式之工厂模式","date":"2017-03-01T14:30:37.000Z","path":"2017/03/01/java设计模式之工厂模式/","text":"什么是工厂模式工厂模式（Factory Pattern）就跟它的名字一样，在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂模式通过不同的参数实现不同的分配方案和对象创建，例如用工厂来创建人这个对象，如果我们需要一个男人，工厂就给我们创建一个男人对象，如果我们需要一个女人，工厂就给我们创建一个女人对象。 工厂模式通常分为： 简单工厂模式 抽象工厂模式 工厂方法模式","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"python中*args和**kwargs的区别","date":"2017-02-25T13:49:35.000Z","path":"2017/02/25/python中-args和-kwargs的区别/","text":"当函数的参数(个数)不确定时，可以使用*args和**kwargs，*args表示参数没有key值，也就是无名参数，是一个tuple，**表示参数有key值，也就是关键字参数，是一个dict。 代码示例：1234567891011def foo(*args, **kwargs): print(&apos;args = &apos;, args) print(&apos;kwargs = &apos;, kwargs) print(&apos;---------------------------------------&apos;)if __name__ == &apos;__main__&apos;: foo(1, 2, 3, 4) foo(a=1, b=2, c=3) foo(1, 2, 3, 4, a=1, b=2, c=3) foo(&apos;a&apos;, 1, None, a=1, b=&apos;2&apos;, c=3) 输出结果为： 123456789101112args = (1, 2, 3, 4)kwargs = &#123;&#125;---------------------------------------args = ()kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: 2&#125;---------------------------------------args = (1, 2, 3, 4)kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: 2&#125;---------------------------------------args = (&apos;a&apos;, 1, None)kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: &apos;2&apos;&#125;--------------------------------------- 需要特别提出注意的一点是，在同时使用*args和**kwargs时，*args参数必须要在**kwargs前，像foo(a=1, b=’2’, c=3, a’, 1, None, )这样调用的话，会提示语法错误“SyntaxError: non-keyword arg after keyword arg”。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"心上人","date":"2017-02-25T05:07:36.000Z","path":"2017/02/25/心上人/","text":"最初 你是我为数不多的阅历里 占有一席之地的明月光 游遍天地找你来世 于是口衔喜烛头蒙喜帕 只等你一次回头 只为等你这一次 我昼尽得出夜不伏 见过白发送少颜 见过扶棺而哭君合目 见过素衣喜死红榜前 没见过你 哭成山河 一口吞下 白银心间挂 叹声心上人 难惊浪游子 也好 那我只当你是 中规中矩中的偏颇 俗世俗尘诉的风月 是千里夜奔，饮酒作乐，做尽欢好事 是生死不明，下落不明，余生难同行 是一片巫山云，惊起雷声阵阵 终究未成雨 可能你我太不幸 只盼你能修成佛陀 我便将这肉身毁了去，筑成佛龛 做不了你心上人，你便来做我身内佛吧 待有善男信女路过，虔诚拜三拜 也算我同你共过天与地了 山雪少见，楂月难掀 你是另一种人间角色","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"使用hexo+github搭建博客教程","date":"2017-02-24T13:46:33.000Z","path":"2017/02/24/使用hexo-github搭建博客教程/","text":"首先简单介绍下本篇教程的主角Hexo,官网的介绍是这样的： A fast, simple &amp; powerful blog framework “一个快速，简单，又强大的博客框架”，啧啧啧，这描述，简直是已经到了福利级别了啊，来来来，让我们hexo到底多福利！ 准备工作再开始一切之前，你必须已经 有一个github账号 安装了nodejs，npm 且了解一些相关知识 安装了gitbash 搭建github博客github给我们提供了非常友好的github.io的仓库来将我们写好的静态页面放置到github pages上，由于只是静态页面，所以访问速度也是非常的快。新建一个名为你的用户名.github.io的仓库(必须是你的用户名，其他名称无效)，将来就用https://你的用户名.github.io来访问了，是不是贼方便!? 几个要注意的地方 一个github账号只能建一个github.io仓库 仓库名必须是你的用户名.github.io 仓库创建成功不会立即生效，需要等一段时间，大概十几二十分钟，等个半个多小时的也有，后面修改页面提交的时候同理 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 相关工具版本因为不同版本的差别比较大，所以特意说明下本教程所使用的各个工具版本 node 6.10.0 npm 4.3.0 hexo 3.2.2 安装1$ npm install -g hexo 初始化在你电脑的某个你满意的地方找个能存放代码的文件夹初始化，最好新建一个吧，以后就不动了1$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g #生成$ hexo s #启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件就是将来要提交到github去的页面 第一次初始化的时候hexo会有个默认页面，因为我的失误忘记了截图，所以就不上图了，当你hexo s启动服务的时候可以按照提示进浏览器多瞅几眼，之所以要多瞅几眼是因为当你瞅多了的时候就默认主题就会丑到你23333333，所以得更换一个更养眼的主题不是。这里是官方主题,你可以进去挑自己喜欢的主题来安装，下面说一下安装主题。 比如我的主题是yilia，首先肯定是下载这个主题，在你的hexo根目录下1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里那个landscape就是hexo默认主题 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 此时你可以重新hexo s启动服务来预览一下你的主题，觉得满意的话就可以上传到github了 上传github上传github非常之简单，只要1$ hexo d 在此之前你还得做一些事情，在_config.yml中配置deploy1234deploy: type:git repo:git@github.com:sherlockkk/sherlockkk.github.io.git branch: master 配置好就可以发布到你的github了，当然，关于git的相关配置在这里就不再做过多赘述，如果没有相关基础请出门右转 如果出现如下报错信息1Deployer not found: github 或者 Deployer not found: git 说明你还需要安装一个插件1npm install hexo-deployer-git --save 然后再次hexo d的时候hexo就会帮你自动提交并部署你所改动的代码 常用hexo命令1234567hexo new \"articleName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客在hexo根目录下1hexo new 'blog' hexo会在/source/_posts文件夹下帮我们自动生成一个blog.md文件，我们只要在这个md文件里写博客就好了 默认生成的文件头应该是这样的1234567---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面--- 到此为止，你的博客应该可以被访问而且你也已经掌握了博客上传到github的方法，而且时间也不早了，我要睡觉了，再写下去明天起不来了，最后的效果呢就是我这样子的https://sherlockkk.github.io/,","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]