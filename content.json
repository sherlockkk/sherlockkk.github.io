[{"title":"IoC概述","date":"2017-03-14T07:38:42.000Z","path":"2017/03/14/IoC概述/","text":"1.IoC是什么？Ioc—Inversion of Control，即“控制反转”.在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 1） 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 2） 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 2.IoC能做什么?IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 3.IoC和DIDI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： 1） 谁依赖于谁：当然是应用程序依赖于IoC容器；2） 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；3） 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；4） 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 4.IoC和DI有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"论如何对Java代码进行基本优化","date":"2017-03-05T07:03:38.000Z","path":"2017/03/05/论如何对Java代码进行基本优化/","text":"0、不要过度依赖GC内存抖动是指在短时间内有大量的对象被创建或者被回收的现象。内存抖动常出现的原因是频繁的在循环中创建对象，如果这种抖动很是频繁，会导致垃圾回收机制的频繁运行。 内存泄漏是指某段内存在程序功能上已经不再需要了，但是垃圾回收机制在回收内存时检测那段内存还是被需要的，不能被回收，这种在程序中没有被使用但是又不能被回收的内存就是泄漏的内存。内存泄漏会导致一些内存没法被正常利用，可用内存减少，轻则增加垃圾回收机制运行频率，重则内存溢出（当系统需要分配一段内存，但现有内存在垃圾回收运行之后仍然不足，就会内溢出） 常见的优化方式是在变量或对象使用完之后，将其手动置空。 1、优化循环语句 避免重复运算123456789//错误写法for(int i = 0; i &lt;= vector.size(i++)&#123; ...&#125;//正确写法int size = vector.size();for(int i = 0; i &lt;= size; i++)&#123; ...&#125; 错误写法中vector对象的size方法每次循环判断中都会调用，虽然该方法执行起来很快，但是叠加起来的性能损耗还是很可怕的。 在循环逻辑中避免大开销的操作所谓大开销的操作是指创建对象、捕获异常等需要大块内存消耗的操作。解决方案是在进行逻辑计算时应该尽量使用基本数据类型，比如int数组,string数组等，变量或对象使用后注意资源回收。 2、慎用异常机制执行异常捕获语句（try catch）和抛出异常（throw）的代价很高。使用异常机制尽量把逻辑放在最外层，并且只用于错误处理，不要用于程序逻辑。 3、基本数据类型运算java中的基本数据类型有byte、short、int、long、float、double、boolean、char，运算方式有加减乘除、位移、布尔运算。进行逻辑运算时需要注意： 运算速度从快到慢依次是int&gt;short&gt;byte&gt;long&gt;double 除法比乘法要慢很多，基本上除法的运算时间是乘法的9倍 long类型的运算很慢，建议少用 double运算速度和float相当 4、字符串操作使用StringBuffer提升效率123456789101112131415//低效写法String appendStr = &quot;test&quot;;int time = 10000;str = &quot;&quot;;for(i = 0; i &lt;= time; i++)&#123; str += appendStr;&#125;//高效写法String appendStr = &quot;test&quot;;int time = 10000;StringBuffer sb = new StringBuffer();for(i = 0; i &lt;= time; i++)&#123; sb.append(appendStr);&#125; 5、合理使用数据集合java的数据集合可分为两种类型，即集合结构（Collection）和图表结构（Map），下面还包括了列表（List），栈（Stack），散列（HashMap）等 Collection|- List| |- LinkedList (双向链表)| |- ArrayList (高级数组)| | Vector (线程安全)| | Stack|_ Set Map|- Hashtable (线程安全)|- HashMap|_ WeakHashMap 其中最常使用的是ArrayList ，该数据集合其实就是一个可变大小的数组，其次是LinkedList ，该集合用于实现栈（stack），队列（queue），双向队列（deque）。Hashtable是同步的 线程安全 。这些应该尽量使用ArrayList和HashMap，谨慎使用Vector和HashTable ，应为后两者为了保证线程安全而使用同步机制，系统开销比较大 编码时尽量使用原生的数据结构如数组，枚举 6、慎用public static final 如果一个变量或者数据被这样声明，那么我们就不能对这个变量进行任何修改了，这种数组也无法进行增删改查 以及排序等操作 这种声明的数据在整个进程被销毁之前都会常驻内存，使用不当有可能会引起一些性能问题。 7、使用对象池提高效率创建和释放对象会占用比较大的系统资源 即把常用的对象存放在一个对象池（对象集合）中，通过一定的策略高效调用已经存在的对象，避免大量的创建对象或销毁对象对象池 如数据库连接池 线程池 8、不要过度使用OOP善于使用语言中的工具类使用Log打印日志的系统资源开销也是不小的，在正式发布应用之前应该把程序中的Log调试代码关闭","tags":[{"name":"代码优化","slug":"代码优化","permalink":"http://yoursite.com/tags/代码优化/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/编程技巧/"}]},{"title":"java设计模式之工厂模式","date":"2017-03-01T14:30:37.000Z","path":"2017/03/01/java设计模式之工厂模式/","text":"什么是工厂模式工厂模式（Factory Pattern）就跟它的名字一样，在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂模式通过不同的参数实现不同的分配方案和对象创建，例如用工厂来创建人这个对象，如果我们需要一个男人，工厂就给我们创建一个男人对象，如果我们需要一个女人，工厂就给我们创建一个女人对象。 工厂模式通常分为： 简单工厂模式 抽象工厂模式 工厂方法模式","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"python中*args和**kwargs的区别","date":"2017-02-25T13:49:35.000Z","path":"2017/02/25/python中-args和-kwargs的区别/","text":"当函数的参数(个数)不确定时，可以使用*args和**kwargs，*args表示参数没有key值，也就是无名参数，是一个tuple，**表示参数有key值，也就是关键字参数，是一个dict。 代码示例：1234567891011def foo(*args, **kwargs): print(&apos;args = &apos;, args) print(&apos;kwargs = &apos;, kwargs) print(&apos;---------------------------------------&apos;)if __name__ == &apos;__main__&apos;: foo(1, 2, 3, 4) foo(a=1, b=2, c=3) foo(1, 2, 3, 4, a=1, b=2, c=3) foo(&apos;a&apos;, 1, None, a=1, b=&apos;2&apos;, c=3) 输出结果为： 123456789101112args = (1, 2, 3, 4)kwargs = &#123;&#125;---------------------------------------args = ()kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: 2&#125;---------------------------------------args = (1, 2, 3, 4)kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: 2&#125;---------------------------------------args = (&apos;a&apos;, 1, None)kwargs = &#123;&apos;c&apos;: 3, &apos;a&apos;: 1, &apos;b&apos;: &apos;2&apos;&#125;--------------------------------------- 需要特别提出注意的一点是，在同时使用*args和**kwargs时，*args参数必须要在**kwargs前，像foo(a=1, b=’2’, c=3, a’, 1, None, )这样调用的话，会提示语法错误“SyntaxError: non-keyword arg after keyword arg”。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"心上人","date":"2017-02-25T05:07:36.000Z","path":"2017/02/25/心上人/","text":"最初 你是我为数不多的阅历里 占有一席之地的明月光 游遍天地找你来世 于是口衔喜烛头蒙喜帕 只等你一次回头 只为等你这一次 我昼尽得出夜不伏 见过白发送少颜 见过扶棺而哭君合目 见过素衣喜死红榜前 没见过你 哭成山河 一口吞下 白银心间挂 叹声心上人 难惊浪游子 也好 那我只当你是 中规中矩中的偏颇 俗世俗尘诉的风月 是千里夜奔，饮酒作乐，做尽欢好事 是生死不明，下落不明，余生难同行 是一片巫山云，惊起雷声阵阵 终究未成雨 可能你我太不幸 只盼你能修成佛陀 我便将这肉身毁了去，筑成佛龛 做不了你心上人，你便来做我身内佛吧 待有善男信女路过，虔诚拜三拜 也算我同你共过天与地了 山雪少见，楂月难掀 你是另一种人间角色","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"使用hexo+github搭建博客教程","date":"2017-02-24T13:46:33.000Z","path":"2017/02/24/使用hexo-github搭建博客教程/","text":"首先简单介绍下本篇教程的主角Hexo,官网的介绍是这样的： A fast, simple &amp; powerful blog framework “一个快速，简单，又强大的博客框架”，啧啧啧，这描述，简直是已经到了福利级别了啊，来来来，让我们hexo到底多福利！ 准备工作再开始一切之前，你必须已经 有一个github账号 安装了nodejs，npm 且了解一些相关知识 安装了gitbash 搭建github博客github给我们提供了非常友好的github.io的仓库来将我们写好的静态页面放置到github pages上，由于只是静态页面，所以访问速度也是非常的快。新建一个名为你的用户名.github.io的仓库(必须是你的用户名，其他名称无效)，将来就用https://你的用户名.github.io来访问了，是不是贼方便!? 几个要注意的地方 一个github账号只能建一个github.io仓库 仓库名必须是你的用户名.github.io 仓库创建成功不会立即生效，需要等一段时间，大概十几二十分钟，等个半个多小时的也有，后面修改页面提交的时候同理 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 相关工具版本因为不同版本的差别比较大，所以特意说明下本教程所使用的各个工具版本 node 6.10.0 npm 4.3.0 hexo 3.2.2 安装1$ npm install -g hexo 初始化在你电脑的某个你满意的地方找个能存放代码的文件夹初始化，最好新建一个吧，以后就不动了1$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g #生成$ hexo s #启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件就是将来要提交到github去的页面 第一次初始化的时候hexo会有个默认页面，因为我的失误忘记了截图，所以就不上图了，当你hexo s启动服务的时候可以按照提示进浏览器多瞅几眼，之所以要多瞅几眼是因为当你瞅多了的时候就默认主题就会丑到你23333333，所以得更换一个更养眼的主题不是。这里是官方主题,你可以进去挑自己喜欢的主题来安装，下面说一下安装主题。 比如我的主题是yilia，首先肯定是下载这个主题，在你的hexo根目录下1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里那个landscape就是hexo默认主题 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 此时你可以重新hexo s启动服务来预览一下你的主题，觉得满意的话就可以上传到github了 上传github上传github非常之简单，只要1$ hexo d 在此之前你还得做一些事情，在_config.yml中配置deploy1234deploy: type:git repo:git@github.com:sherlockkk/sherlockkk.github.io.git branch: master 配置好就可以发布到你的github了，当然，关于git的相关配置在这里就不再做过多赘述，如果没有相关基础请出门右转 如果出现如下报错信息1Deployer not found: github 或者 Deployer not found: git 说明你还需要安装一个插件1npm install hexo-deployer-git --save 然后再次hexo d的时候hexo就会帮你自动提交并部署你所改动的代码 常用hexo命令1234567hexo new \"articleName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客在hexo根目录下1hexo new 'blog' hexo会在/source/_posts文件夹下帮我们自动生成一个blog.md文件，我们只要在这个md文件里写博客就好了 默认生成的文件头应该是这样的1234567---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面--- 到此为止，你的博客应该可以被访问而且你也已经掌握了博客上传到github的方法，而且时间也不早了，我要睡觉了，再写下去明天起不来了，最后的效果呢就是我这样子的https://sherlockkk.github.io/,","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]